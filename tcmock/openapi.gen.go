//go:build go1.22

// Package tcmock provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package tcmock

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/oapi-codegen/nullable"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	APIKEYScopes = "APIKEY.Scopes"
	SIGNEDScopes = "SIGNED.Scopes"
)

// Defines values for BotBaseOrderVolumeType.
const (
	BotBaseOrderVolumeTypeBaseCurrency  BotBaseOrderVolumeType = "base_currency"
	BotBaseOrderVolumeTypePercent       BotBaseOrderVolumeType = "percent"
	BotBaseOrderVolumeTypeQuoteCurrency BotBaseOrderVolumeType = "quote_currency"
)

// Defines values for BotLeverageType.
const (
	BotLeverageTypeCross    BotLeverageType = "cross"
	BotLeverageTypeIsolated BotLeverageType = "isolated"
)

// Defines values for BotMinProfitType.
const (
	BotMinProfitTypeBaseOrderVolume   BotMinProfitType = "base_order_volume"
	BotMinProfitTypeTotalBoughtVolume BotMinProfitType = "total_bought_volume"
)

// Defines values for BotProfitCurrency.
const (
	BotProfitCurrencyBaseCurrency  BotProfitCurrency = "base_currency"
	BotProfitCurrencyQuoteCurrency BotProfitCurrency = "quote_currency"
)

// Defines values for BotSafetyOrderVolumeType.
const (
	BotSafetyOrderVolumeTypeBaseCurrency  BotSafetyOrderVolumeType = "base_currency"
	BotSafetyOrderVolumeTypePercent       BotSafetyOrderVolumeType = "percent"
	BotSafetyOrderVolumeTypeQuoteCurrency BotSafetyOrderVolumeType = "quote_currency"
)

// Defines values for BotStartOrderType.
const (
	BotStartOrderTypeLimit  BotStartOrderType = "limit"
	BotStartOrderTypeMarket BotStartOrderType = "market"
)

// Defines values for BotStopLossType.
const (
	BotStopLossTypeStopLoss              BotStopLossType = "stop_loss"
	BotStopLossTypeStopLossAndDisableBot BotStopLossType = "stop_loss_and_disable_bot"
)

// Defines values for BotStrategy.
const (
	BotStrategyLong  BotStrategy = "long"
	BotStrategyShort BotStrategy = "short"
)

// Defines values for BotTakeProfitType.
const (
	BotTakeProfitTypeBase  BotTakeProfitType = "base"
	BotTakeProfitTypeTotal BotTakeProfitType = "total"
)

// Defines values for BotEntityBaseOrderVolumeType.
const (
	BotEntityBaseOrderVolumeTypeBaseCurrency  BotEntityBaseOrderVolumeType = "base_currency"
	BotEntityBaseOrderVolumeTypePercent       BotEntityBaseOrderVolumeType = "percent"
	BotEntityBaseOrderVolumeTypeQuoteCurrency BotEntityBaseOrderVolumeType = "quote_currency"
)

// Defines values for BotEntityLeverageType.
const (
	BotEntityLeverageTypeCross    BotEntityLeverageType = "cross"
	BotEntityLeverageTypeIsolated BotEntityLeverageType = "isolated"
)

// Defines values for BotEntityMinProfitType.
const (
	BotEntityMinProfitTypeBaseOrderVolume   BotEntityMinProfitType = "base_order_volume"
	BotEntityMinProfitTypeTotalBoughtVolume BotEntityMinProfitType = "total_bought_volume"
)

// Defines values for BotEntityProfitCurrency.
const (
	BotEntityProfitCurrencyBaseCurrency  BotEntityProfitCurrency = "base_currency"
	BotEntityProfitCurrencyQuoteCurrency BotEntityProfitCurrency = "quote_currency"
)

// Defines values for BotEntitySafetyOrderVolumeType.
const (
	BotEntitySafetyOrderVolumeTypeBaseCurrency  BotEntitySafetyOrderVolumeType = "base_currency"
	BotEntitySafetyOrderVolumeTypePercent       BotEntitySafetyOrderVolumeType = "percent"
	BotEntitySafetyOrderVolumeTypeQuoteCurrency BotEntitySafetyOrderVolumeType = "quote_currency"
)

// Defines values for BotEntityStartOrderType.
const (
	BotEntityStartOrderTypeLimit  BotEntityStartOrderType = "limit"
	BotEntityStartOrderTypeMarket BotEntityStartOrderType = "market"
)

// Defines values for BotEntityStopLossType.
const (
	BotEntityStopLossTypeStopLoss              BotEntityStopLossType = "stop_loss"
	BotEntityStopLossTypeStopLossAndDisableBot BotEntityStopLossType = "stop_loss_and_disable_bot"
)

// Defines values for BotEntityStrategy.
const (
	BotEntityStrategyLong  BotEntityStrategy = "long"
	BotEntityStrategyShort BotEntityStrategy = "short"
)

// Defines values for BotEntityTakeProfitType.
const (
	BotEntityTakeProfitTypeBase  BotEntityTakeProfitType = "base"
	BotEntityTakeProfitTypeTotal BotEntityTakeProfitType = "total"
)

// Defines values for DealStatus.
const (
	DealStatusBought    DealStatus = "bought"
	DealStatusCompleted DealStatus = "completed"
	DealStatusFailed    DealStatus = "failed"
)

// Defines values for DealTakeProfitType.
const (
	DealTakeProfitTypeBase  DealTakeProfitType = "base"
	DealTakeProfitTypeTotal DealTakeProfitType = "total"
)

// Defines values for DealUpdateRequestProfitCurrency.
const (
	BaseCurrency  DealUpdateRequestProfitCurrency = "base_currency"
	QuoteCurrency DealUpdateRequestProfitCurrency = "quote_currency"
)

// Defines values for DealUpdateRequestStopLossType.
const (
	DealUpdateRequestStopLossTypeStopLoss              DealUpdateRequestStopLossType = "stop_loss"
	DealUpdateRequestStopLossTypeStopLossAndDisableBot DealUpdateRequestStopLossType = "stop_loss_and_disable_bot"
)

// Defines values for DealUpdateRequestTakeProfitType.
const (
	DealUpdateRequestTakeProfitTypeBase  DealUpdateRequestTakeProfitType = "base"
	DealUpdateRequestTakeProfitTypeTotal DealUpdateRequestTakeProfitType = "total"
)

// Defines values for MarketListItemAvailableConnectionFlows.
const (
	FastConnect MarketListItemAvailableConnectionFlows = "fast_connect"
	Form        MarketListItemAvailableConnectionFlows = "form"
)

// Defines values for MarketOrderDealOrderType.
const (
	MarketOrderDealOrderTypeBase         MarketOrderDealOrderType = "Base"
	MarketOrderDealOrderTypeManualSafety MarketOrderDealOrderType = "Manual Safety"
	MarketOrderDealOrderTypeSafety       MarketOrderDealOrderType = "Safety"
	MarketOrderDealOrderTypeStopLoss     MarketOrderDealOrderType = "Stop Loss"
	MarketOrderDealOrderTypeTakeProfit   MarketOrderDealOrderType = "Take Profit"
)

// Defines values for MarketOrderOrderType.
const (
	BUY  MarketOrderOrderType = "BUY"
	SELL MarketOrderOrderType = "SELL"
)

// Defines values for MarketOrderStatusString.
const (
	Active    MarketOrderStatusString = "Active"
	Cancelled MarketOrderStatusString = "Cancelled"
	Filled    MarketOrderStatusString = "Filled"
	Finished  MarketOrderStatusString = "Finished"
	Inactive  MarketOrderStatusString = "Inactive"
)

// Defines values for StrategyConfigStrategy.
const (
	Manual      StrategyConfigStrategy = "manual"
	Nonstop     StrategyConfigStrategy = "nonstop"
	Rsi         StrategyConfigStrategy = "rsi"
	TradingView StrategyConfigStrategy = "trading_view"
)

// Defines values for GetCurrencyRatesParamsLimitType.
const (
	GetCurrencyRatesParamsLimitTypeBot        GetCurrencyRatesParamsLimitType = "bot"
	GetCurrencyRatesParamsLimitTypeSmartTrade GetCurrencyRatesParamsLimitType = "smart_trade"
)

// Defines values for ListBotsParamsStrategy.
const (
	ListBotsParamsStrategyLong  ListBotsParamsStrategy = "long"
	ListBotsParamsStrategyShort ListBotsParamsStrategy = "short"
)

// Defines values for ListBotsParamsOrderDirection.
const (
	ListBotsParamsOrderDirectionASC  ListBotsParamsOrderDirection = "ASC"
	ListBotsParamsOrderDirectionDESC ListBotsParamsOrderDirection = "DESC"
)

// Defines values for ListBotsParamsScope.
const (
	Disabled ListBotsParamsScope = "disabled"
	Enabled  ListBotsParamsScope = "enabled"
)

// Defines values for ListBotsParamsSortBy.
const (
	ListBotsParamsSortByCreatedAt ListBotsParamsSortBy = "created_at"
	ListBotsParamsSortByProfit    ListBotsParamsSortBy = "profit"
	ListBotsParamsSortByUpdatedAt ListBotsParamsSortBy = "updated_at"
)

// Defines values for ListStrategiesParamsType.
const (
	ListStrategiesParamsTypeLong  ListStrategiesParamsType = "long"
	ListStrategiesParamsTypeShort ListStrategiesParamsType = "short"
)

// Defines values for ListStrategiesParamsStrategy.
const (
	Composite ListStrategiesParamsStrategy = "composite"
	Simple    ListStrategiesParamsStrategy = "simple"
)

// Defines values for ListDealsParamsScope.
const (
	ListDealsParamsScopeActive    ListDealsParamsScope = "active"
	ListDealsParamsScopeCancelled ListDealsParamsScope = "cancelled"
	ListDealsParamsScopeCompleted ListDealsParamsScope = "completed"
	ListDealsParamsScopeFailed    ListDealsParamsScope = "failed"
	ListDealsParamsScopeFinished  ListDealsParamsScope = "finished"
)

// Defines values for ListDealsParamsOrder.
const (
	ListDealsParamsOrderClosedAt         ListDealsParamsOrder = "closed_at"
	ListDealsParamsOrderCreatedAt        ListDealsParamsOrder = "created_at"
	ListDealsParamsOrderProfit           ListDealsParamsOrder = "profit"
	ListDealsParamsOrderProfitPercentage ListDealsParamsOrder = "profit_percentage"
	ListDealsParamsOrderUpdatedAt        ListDealsParamsOrder = "updated_at"
)

// Defines values for ListDealsParamsOrderDirection.
const (
	ListDealsParamsOrderDirectionASC  ListDealsParamsOrderDirection = "ASC"
	ListDealsParamsOrderDirectionDESC ListDealsParamsOrderDirection = "DESC"
)

// Bot defines model for Bot.
type Bot struct {
	// AccountId ID of the exchange account entity where you want to create the DCA Bot.
	AccountId int `json:"account_id"`

	// AccountName Exchange-account name shown to the user.
	AccountName string `json:"account_name"`

	// ActiveDeals List of active deals managed by this DCA Bot.
	ActiveDeals []Deal `json:"active_deals"`

	// ActiveDealsBtcProfit Unrealised P/L of active deals (BTC).
	ActiveDealsBtcProfit string `json:"active_deals_btc_profit"`

	// ActiveDealsCount Number of active deals.
	ActiveDealsCount int `json:"active_deals_count"`

	// ActiveDealsUsdProfit Unrealised P/L of active deals (USD).
	ActiveDealsUsdProfit string `json:"active_deals_usd_profit"`

	// ActiveSafetyOrdersCount Number of safety orders the bot may place concurrently.
	ActiveSafetyOrdersCount *int `json:"active_safety_orders_count,omitempty"`

	// AllowedDealsOnSamePair Max concurrent deals on the same pair (MultiBot only).
	AllowedDealsOnSamePair *int `json:"allowed_deals_on_same_pair,omitempty"`

	// BaseOrderVolume The volume of the base order for this DCA Bot.
	BaseOrderVolume *string `json:"base_order_volume,omitempty"`

	// BaseOrderVolumeType The volume type of the base order.
	BaseOrderVolumeType *BotBaseOrderVolumeType `json:"base_order_volume_type,omitempty"`

	// BtcFundsLockedInActiveDeals BTC currently locked in active deals.
	BtcFundsLockedInActiveDeals string `json:"btc_funds_locked_in_active_deals"`

	// CloseDealsTimeout Auto-close deals after this many seconds.
	CloseDealsTimeout *string `json:"close_deals_timeout,omitempty"`

	// CloseStrategyList Array of strategies used for closing deals.
	CloseStrategyList *[]StrategyConfig `json:"close_strategy_list,omitempty"`

	// Cooldown Time after closing a deal before a new one can start (seconds).
	Cooldown *string `json:"cooldown,omitempty"`

	// CreatedAt ISO-8601 timestamp when the bot was created.
	CreatedAt time.Time `json:"created_at"`

	// DealStartDelaySeconds Delay before a new deal starts (seconds).
	DealStartDelaySeconds *int `json:"deal_start_delay_seconds,omitempty"`

	// Deletable Indicates whether this bot can be deleted.
	Deletable bool `json:"deletable?"`

	// DisableAfterDealsCount Number of deals after which the bot disables itself.
	DisableAfterDealsCount *int `json:"disable_after_deals_count,omitempty"`

	// FinishedDealsCount Total number of finished deals.
	FinishedDealsCount string `json:"finished_deals_count"`

	// FinishedDealsProfitUsd Cumulative USD profit from finished deals.
	FinishedDealsProfitUsd string `json:"finished_deals_profit_usd"`

	// FundsLockedInActiveDeals USD currently locked in active deals.
	FundsLockedInActiveDeals string `json:"funds_locked_in_active_deals"`

	// Id Unique 3Commas ID for this DCA Bot.
	Id int `json:"id"`

	// IsEnabled Whether the bot is currently enabled.
	IsEnabled bool `json:"is_enabled"`

	// LeverageCustomValue Leverage value (exchange- and pair-dependent).
	LeverageCustomValue *float32 `json:"leverage_custom_value,omitempty"`

	// LeverageType Sets leverage settings for a futures account.
	LeverageType *BotLeverageType `json:"leverage_type,omitempty"`

	// MartingaleStepCoefficient Multiplier for increasing safety order step (Martingale).
	MartingaleStepCoefficient *string `json:"martingale_step_coefficient,omitempty"`

	// MartingaleVolumeCoefficient Multiplier for increasing safety order volume (Martingale).
	MartingaleVolumeCoefficient *string `json:"martingale_volume_coefficient,omitempty"`

	// MaxActiveDeals The maximum number of active deals available for this DCA Bot.
	MaxActiveDeals *int `json:"max_active_deals,omitempty"`

	// MaxPrice Maximum price to open a new deal.
	MaxPrice *float32 `json:"max_price,omitempty"`

	// MaxPricePercentage Maximum entry price percentage (−95 to 1000).
	MaxPricePercentage *float32 `json:"max_price_percentage,omitempty"`

	// MaxSafetyOrders Maximum total number of safety orders per deal.
	MaxSafetyOrders *int `json:"max_safety_orders,omitempty"`

	// MinPrice Minimum price to open a new deal.
	MinPrice *float32 `json:"min_price,omitempty"`

	// MinPricePercentage Minimum entry price percentage (−95 to 1000).
	MinPricePercentage *float32 `json:"min_price_percentage,omitempty"`

	// MinProfitPercentage Minimum profit percentage required to complete a deal.
	MinProfitPercentage *string `json:"min_profit_percentage,omitempty"`

	// MinProfitType Basis for minimum profit calculation.
	MinProfitType *BotMinProfitType `json:"min_profit_type,omitempty"`

	// MinVolumeBtc24h Minimum 24h BTC volume required to open a deal.
	MinVolumeBtc24h *string `json:"min_volume_btc_24h,omitempty"`

	// Name User-defined name of the DCA Bot. If not specified, the system will generate a default name automatically.
	Name *string `json:"name,omitempty"`

	// Pairs Trading pair(s) in 3Commas format.
	Pairs Pairs `json:"pairs"`

	// ProfitCurrency Currency used for profit calculation: base_currency or quote_currency.
	ProfitCurrency *BotProfitCurrency `json:"profit_currency,omitempty"`

	// ReinvestedVolumeUsd USD volume reinvested from profit.
	ReinvestedVolumeUsd nullable.Nullable[float32] `json:"reinvested_volume_usd"`

	// ReinvestingPercentage Percentage of realized profit to reinvest in each new deal.
	ReinvestingPercentage *string `json:"reinvesting_percentage,omitempty"`

	// RiskReductionPercentage Percentage of losses to reduce base and safety orders proportionally.
	RiskReductionPercentage *string `json:"risk_reduction_percentage,omitempty"`

	// SafetyOrderStepPercentage Price deviation (%) to open each safety order.
	SafetyOrderStepPercentage *string `json:"safety_order_step_percentage,omitempty"`

	// SafetyOrderVolume Volume of each safety order.
	SafetyOrderVolume *string `json:"safety_order_volume,omitempty"`

	// SafetyOrderVolumeType Volume type for safety orders.
	SafetyOrderVolumeType *BotSafetyOrderVolumeType `json:"safety_order_volume_type,omitempty"`

	// SafetyStrategyList Array of strategies for executing safety orders.
	SafetyStrategyList *[]StrategyConfig `json:"safety_strategy_list,omitempty"`

	// SlToBreakevenData Configuration for breakeven trigger levels (0 = entry price, 1 = first TP step, etc.).
	SlToBreakevenData *map[string]interface{} `json:"sl_to_breakeven_data,omitempty"`

	// SlToBreakevenEnabled Enables the Move-to-Breakeven feature.
	SlToBreakevenEnabled *bool `json:"sl_to_breakeven_enabled,omitempty"`

	// StartOrderType The start order type for this DCA Bot.
	StartOrderType *BotStartOrderType `json:"start_order_type,omitempty"`

	// StopLossPercentage Percentage drop to trigger Stop Loss.
	StopLossPercentage *string `json:"stop_loss_percentage,omitempty"`

	// StopLossTimeoutEnabled Enables Stop Loss timeout.
	StopLossTimeoutEnabled *bool `json:"stop_loss_timeout_enabled,omitempty"`

	// StopLossTimeoutInSeconds Timeout duration in seconds for Stop Loss.
	StopLossTimeoutInSeconds *int `json:"stop_loss_timeout_in_seconds,omitempty"`

	// StopLossType Action after Stop Loss closes a deal.
	StopLossType *BotStopLossType `json:"stop_loss_type,omitempty"`

	// Strategy The type of trading strategy used by this DCA Bot.
	Strategy *BotStrategy `json:"strategy,omitempty"`

	// StrategyList Array of strategies specifically for opening deals.
	StrategyList *[]StrategyConfig `json:"strategy_list,omitempty"`

	// TakeProfit Percentage value for the bot’s Take Profit. Set to 0 if using steps.
	TakeProfit *string `json:"take_profit,omitempty"`

	// TakeProfitSteps Take Profit steps (up to 4), each with:
	// - amount_percentage
	// - profit_percentage
	TakeProfitSteps *[]TakeProfitStep `json:"take_profit_steps,omitempty"`

	// TakeProfitType Basis for Take Profit calculation.
	TakeProfitType *BotTakeProfitType `json:"take_profit_type,omitempty"`

	// TrailingDeviation Percentage value of the trailing deviation.
	TrailingDeviation *string `json:"trailing_deviation,omitempty"`

	// TrailingEnabled Enables trailing for Take Profit.
	TrailingEnabled *bool `json:"trailing_enabled,omitempty"`

	// TslEnabled Enables trailing for Stop Loss.
	TslEnabled *bool `json:"tsl_enabled,omitempty"`

	// UpdatedAt ISO-8601 timestamp of last update.
	UpdatedAt time.Time `json:"updated_at"`
}

// BotBaseOrderVolumeType The volume type of the base order.
type BotBaseOrderVolumeType string

// BotLeverageType Sets leverage settings for a futures account.
type BotLeverageType string

// BotMinProfitType Basis for minimum profit calculation.
type BotMinProfitType string

// BotProfitCurrency Currency used for profit calculation: base_currency or quote_currency.
type BotProfitCurrency string

// BotSafetyOrderVolumeType Volume type for safety orders.
type BotSafetyOrderVolumeType string

// BotStartOrderType The start order type for this DCA Bot.
type BotStartOrderType string

// BotStopLossType Action after Stop Loss closes a deal.
type BotStopLossType string

// BotStrategy The type of trading strategy used by this DCA Bot.
type BotStrategy string

// BotTakeProfitType Basis for Take Profit calculation.
type BotTakeProfitType string

// BotEntity defines model for BotEntity.
type BotEntity struct {
	// AccountId ID of the exchange account entity where you want to create the DCA Bot.
	AccountId int `json:"account_id"`

	// ActiveSafetyOrdersCount Number of safety orders the bot may place concurrently.
	ActiveSafetyOrdersCount *int `json:"active_safety_orders_count,omitempty"`

	// AllowedDealsOnSamePair Max concurrent deals on the same pair (MultiBot only).
	AllowedDealsOnSamePair *int `json:"allowed_deals_on_same_pair,omitempty"`

	// BaseOrderVolume The volume of the base order for this DCA Bot.
	BaseOrderVolume *string `json:"base_order_volume,omitempty"`

	// BaseOrderVolumeType The volume type of the base order.
	BaseOrderVolumeType *BotEntityBaseOrderVolumeType `json:"base_order_volume_type,omitempty"`

	// CloseDealsTimeout Auto-close deals after this many seconds.
	CloseDealsTimeout *string `json:"close_deals_timeout,omitempty"`

	// CloseStrategyList Array of strategies used for closing deals.
	CloseStrategyList *[]StrategyConfig `json:"close_strategy_list,omitempty"`

	// Cooldown Time after closing a deal before a new one can start (seconds).
	Cooldown *string `json:"cooldown,omitempty"`

	// DealStartDelaySeconds Delay before a new deal starts (seconds).
	DealStartDelaySeconds *int `json:"deal_start_delay_seconds,omitempty"`

	// DisableAfterDealsCount Number of deals after which the bot disables itself.
	DisableAfterDealsCount *int `json:"disable_after_deals_count,omitempty"`

	// LeverageCustomValue Leverage value (exchange- and pair-dependent).
	LeverageCustomValue *float32 `json:"leverage_custom_value,omitempty"`

	// LeverageType Sets leverage settings for a futures account.
	LeverageType *BotEntityLeverageType `json:"leverage_type,omitempty"`

	// MartingaleStepCoefficient Multiplier for increasing safety order step (Martingale).
	MartingaleStepCoefficient *string `json:"martingale_step_coefficient,omitempty"`

	// MartingaleVolumeCoefficient Multiplier for increasing safety order volume (Martingale).
	MartingaleVolumeCoefficient *string `json:"martingale_volume_coefficient,omitempty"`

	// MaxActiveDeals The maximum number of active deals available for this DCA Bot.
	MaxActiveDeals *int `json:"max_active_deals,omitempty"`

	// MaxPrice Maximum price to open a new deal.
	MaxPrice *float32 `json:"max_price,omitempty"`

	// MaxPricePercentage Maximum entry price percentage (−95 to 1000).
	MaxPricePercentage *float32 `json:"max_price_percentage,omitempty"`

	// MaxSafetyOrders Maximum total number of safety orders per deal.
	MaxSafetyOrders *int `json:"max_safety_orders,omitempty"`

	// MinPrice Minimum price to open a new deal.
	MinPrice *float32 `json:"min_price,omitempty"`

	// MinPricePercentage Minimum entry price percentage (−95 to 1000).
	MinPricePercentage *float32 `json:"min_price_percentage,omitempty"`

	// MinProfitPercentage Minimum profit percentage required to complete a deal.
	MinProfitPercentage *string `json:"min_profit_percentage,omitempty"`

	// MinProfitType Basis for minimum profit calculation.
	MinProfitType *BotEntityMinProfitType `json:"min_profit_type,omitempty"`

	// MinVolumeBtc24h Minimum 24h BTC volume required to open a deal.
	MinVolumeBtc24h *string `json:"min_volume_btc_24h,omitempty"`

	// Name User-defined name of the DCA Bot. If not specified, the system will generate a default name automatically.
	Name *string `json:"name,omitempty"`

	// Pairs Trading pair(s) in 3Commas format.
	Pairs Pairs `json:"pairs"`

	// ProfitCurrency Currency used for profit calculation: base_currency or quote_currency.
	ProfitCurrency *BotEntityProfitCurrency `json:"profit_currency,omitempty"`

	// ReinvestingPercentage Percentage of realized profit to reinvest in each new deal.
	ReinvestingPercentage *string `json:"reinvesting_percentage,omitempty"`

	// RiskReductionPercentage Percentage of losses to reduce base and safety orders proportionally.
	RiskReductionPercentage *string `json:"risk_reduction_percentage,omitempty"`

	// SafetyOrderStepPercentage Price deviation (%) to open each safety order.
	SafetyOrderStepPercentage *string `json:"safety_order_step_percentage,omitempty"`

	// SafetyOrderVolume Volume of each safety order.
	SafetyOrderVolume *string `json:"safety_order_volume,omitempty"`

	// SafetyOrderVolumeType Volume type for safety orders.
	SafetyOrderVolumeType *BotEntitySafetyOrderVolumeType `json:"safety_order_volume_type,omitempty"`

	// SafetyStrategyList Array of strategies for executing safety orders.
	SafetyStrategyList *[]StrategyConfig `json:"safety_strategy_list,omitempty"`

	// SlToBreakevenData Configuration for breakeven trigger levels (0 = entry price, 1 = first TP step, etc.).
	SlToBreakevenData *map[string]interface{} `json:"sl_to_breakeven_data,omitempty"`

	// SlToBreakevenEnabled Enables the Move-to-Breakeven feature.
	SlToBreakevenEnabled *bool `json:"sl_to_breakeven_enabled,omitempty"`

	// StartOrderType The start order type for this DCA Bot.
	StartOrderType *BotEntityStartOrderType `json:"start_order_type,omitempty"`

	// StopLossPercentage Percentage drop to trigger Stop Loss.
	StopLossPercentage *string `json:"stop_loss_percentage,omitempty"`

	// StopLossTimeoutEnabled Enables Stop Loss timeout.
	StopLossTimeoutEnabled *bool `json:"stop_loss_timeout_enabled,omitempty"`

	// StopLossTimeoutInSeconds Timeout duration in seconds for Stop Loss.
	StopLossTimeoutInSeconds *int `json:"stop_loss_timeout_in_seconds,omitempty"`

	// StopLossType Action after Stop Loss closes a deal.
	StopLossType *BotEntityStopLossType `json:"stop_loss_type,omitempty"`

	// Strategy The type of trading strategy used by this DCA Bot.
	Strategy *BotEntityStrategy `json:"strategy,omitempty"`

	// StrategyList Array of strategies specifically for opening deals.
	StrategyList *[]StrategyConfig `json:"strategy_list,omitempty"`

	// TakeProfit Percentage value for the bot’s Take Profit. Set to 0 if using steps.
	TakeProfit *string `json:"take_profit,omitempty"`

	// TakeProfitSteps Take Profit steps (up to 4), each with:
	// - amount_percentage
	// - profit_percentage
	TakeProfitSteps *[]TakeProfitStep `json:"take_profit_steps,omitempty"`

	// TakeProfitType Basis for Take Profit calculation.
	TakeProfitType *BotEntityTakeProfitType `json:"take_profit_type,omitempty"`

	// TrailingDeviation Percentage value of the trailing deviation.
	TrailingDeviation *string `json:"trailing_deviation,omitempty"`

	// TrailingEnabled Enables trailing for Take Profit.
	TrailingEnabled *bool `json:"trailing_enabled,omitempty"`

	// TslEnabled Enables trailing for Stop Loss.
	TslEnabled *bool `json:"tsl_enabled,omitempty"`
}

// BotEntityBaseOrderVolumeType The volume type of the base order.
type BotEntityBaseOrderVolumeType string

// BotEntityLeverageType Sets leverage settings for a futures account.
type BotEntityLeverageType string

// BotEntityMinProfitType Basis for minimum profit calculation.
type BotEntityMinProfitType string

// BotEntityProfitCurrency Currency used for profit calculation: base_currency or quote_currency.
type BotEntityProfitCurrency string

// BotEntitySafetyOrderVolumeType Volume type for safety orders.
type BotEntitySafetyOrderVolumeType string

// BotEntityStartOrderType The start order type for this DCA Bot.
type BotEntityStartOrderType string

// BotEntityStopLossType Action after Stop Loss closes a deal.
type BotEntityStopLossType string

// BotEntityStrategy The type of trading strategy used by this DCA Bot.
type BotEntityStrategy string

// BotEntityTakeProfitType Basis for Take Profit calculation.
type BotEntityTakeProfitType string

// BotsStats defines model for BotsStats.
type BotsStats struct {
	// OverallStats Cumulative profit or loss by currency for all trading activity.
	OverallStats *map[string]string `json:"overall_stats,omitempty"`

	// ProfitsInUsd Detailed profit and loss data in USD.
	ProfitsInUsd *struct {
		// ActiveDealsUsdProfit USD profit or loss from active (unclosed) deals.
		ActiveDealsUsdProfit float32 `json:"active_deals_usd_profit"`

		// FundsLockedInActiveDeals Funds locked in active deals, in USD.
		FundsLockedInActiveDeals float32 `json:"funds_locked_in_active_deals"`

		// OverallUsdProfit Cumulative USD profit or loss from all trading activity.
		OverallUsdProfit float32 `json:"overall_usd_profit"`

		// TodayUsdProfit USD profit or loss accumulated for the current day.
		TodayUsdProfit float32 `json:"today_usd_profit"`
	} `json:"profits_in_usd,omitempty"`

	// TodayStats Today's profit or loss by currency.
	TodayStats *map[string]string `json:"today_stats,omitempty"`
}

// BotsStatsByDate defines model for BotsStatsByDate.
type BotsStatsByDate struct {
	// BtcProfit BTC profit from deals for the specified day.
	BtcProfit string `json:"btc_profit"`

	// Stats Profit by currency for the specified date.
	Stats map[string]string `json:"stats"`

	// UsdProfit USD profit from deals for the specified day.
	UsdProfit string `json:"usd_profit"`
}

// CopyBotRequest defines model for CopyBotRequest.
type CopyBotRequest struct {
	// Amount Amount allocated for bot usage.
	Amount float32 `json:"amount"`

	// Name The name for the new DCA Bot specified by the user.
	Name string `json:"name"`

	// Secret A unique code used for copying this bot, retrieved from the url_secret parameter.
	Secret string `json:"secret"`
}

// CopyBotResponse defines model for CopyBotResponse.
type CopyBotResponse struct {
	// BotId Unique 3Commas ID for the newly created DCA Bot.
	BotId *float32 `json:"bot_id,omitempty"`

	// BotRequiredAmount The minimum amount of funds required to launch this bot.
	BotRequiredAmount *float32 `json:"bot_required_amount,omitempty"`
}

// CreateBotRequest defines model for CreateBotRequest.
type CreateBotRequest = BotEntity

// CurrencyRates defines model for CurrencyRates.
type CurrencyRates struct {
	// Ask Ask price.
	Ask string `json:"ask"`

	// AskMultiplierDown A multiplier applied to decrease the ask price.
	AskMultiplierDown string `json:"askMultiplierDown"`

	// AskMultiplierUp A multiplier applied to increase the ask price.
	AskMultiplierUp string `json:"askMultiplierUp"`

	// Bid Bid price.
	Bid string `json:"bid"`

	// BidMultiplierDown A multiplier applied to decrease the bid price.
	BidMultiplierDown string `json:"bidMultiplierDown"`

	// BidMultiplierUp A multiplier applied to increase the bid price.
	BidMultiplierUp string `json:"bidMultiplierUp"`

	// ContractStrategyName The strategy by which the contract price is calculated.
	ContractStrategyName string `json:"contract_strategy_name"`

	// InstrumentKind The type of exchange instrument.
	InstrumentKind string `json:"instrumentKind"`

	// Last Last price.
	Last string `json:"last"`

	// LotStep Order of changing the size in Base currency.
	LotStep string `json:"lotStep"`

	// MaxLotSize Maximum order size in Base.
	MaxLotSize string `json:"maxLotSize"`

	// MaxMarketBuyAmount Maximum order size in Base currency for buy.
	MaxMarketBuyAmount string `json:"maxMarketBuyAmount"`

	// MaxMarketSellAmount Maximum order size in Base currency for sell.
	MaxMarketSellAmount string `json:"maxMarketSellAmount"`

	// MaxPrice Maximum price order.
	MaxPrice string `json:"maxPrice"`

	// MaxTotal Maximum order size in Quote.
	MaxTotal string `json:"maxTotal"`

	// MinLotSize The minimum lot size for order in Base currency.
	MinLotSize string `json:"minLotSize"`

	// MinMarketTotal Minimum order size in Quote for market order.
	MinMarketTotal string `json:"minMarketTotal"`

	// MinPrice Minimum price order.
	MinPrice string `json:"minPrice"`

	// MinTotal Minimum order size in Quote.
	MinTotal string `json:"minTotal"`

	// OrderbookAsk Ask price of ticker.
	OrderbookAsk string `json:"orderbook_ask"`

	// OrderbookBid Bid price of ticker.
	OrderbookBid string `json:"orderbook_bid"`

	// OrderbookLast Last price of ticker.
	OrderbookLast string `json:"orderbook_last"`

	// OrderbookPriceCurrency Currency price of ticker.
	OrderbookPriceCurrency string `json:"orderbook_price_currency"`

	// PriceStep The minimum step for changing the price.
	PriceStep string `json:"priceStep"`

	// StrategyName The name of trading strategy.
	StrategyName string `json:"strategy_name"`
}

// CurrencyRatesWithLeverageData defines model for CurrencyRatesWithLeverageData.
type CurrencyRatesWithLeverageData struct {
	// Ask Ask price.
	Ask string `json:"ask"`

	// AskMultiplierDown A multiplier applied to decrease the ask price.
	AskMultiplierDown string `json:"askMultiplierDown"`

	// AskMultiplierUp A multiplier applied to increase the ask price.
	AskMultiplierUp string `json:"askMultiplierUp"`

	// Bid Bid price.
	Bid string `json:"bid"`

	// BidMultiplierDown A multiplier applied to decrease the bid price.
	BidMultiplierDown string `json:"bidMultiplierDown"`

	// BidMultiplierUp A multiplier applied to increase the bid price.
	BidMultiplierUp string `json:"bidMultiplierUp"`

	// ContractStrategyName The strategy by which the contract price is calculated.
	ContractStrategyName string `json:"contract_strategy_name"`

	// InstrumentKind The type of exchange instrument.
	InstrumentKind string `json:"instrumentKind"`

	// Last Last price.
	Last string `json:"last"`

	// LeverageData Represents leverage data for this pair.
	LeverageData []LeverageData `json:"leverage_data"`

	// LotStep Order of changing the size in Base currency.
	LotStep string `json:"lotStep"`

	// MaxLotSize Maximum order size in Base.
	MaxLotSize string `json:"maxLotSize"`

	// MaxMarketBuyAmount Maximum order size in Base currency for buy.
	MaxMarketBuyAmount string `json:"maxMarketBuyAmount"`

	// MaxMarketSellAmount Maximum order size in Base currency for sell.
	MaxMarketSellAmount string `json:"maxMarketSellAmount"`

	// MaxPrice Maximum price order.
	MaxPrice string `json:"maxPrice"`

	// MaxTotal Maximum order size in Quote.
	MaxTotal string `json:"maxTotal"`

	// MinLotSize The minimum lot size for order in Base currency.
	MinLotSize string `json:"minLotSize"`

	// MinMarketBuyAmount Minimum order size in Base currency for buy.
	MinMarketBuyAmount *string `json:"minMarketBuyAmount,omitempty"`

	// MinMarketSellAmount Minimum order size in Base currency for sell.
	MinMarketSellAmount *string `json:"minMarketSellAmount,omitempty"`

	// MinMarketTotal Minimum order size in Quote for market order.
	MinMarketTotal string `json:"minMarketTotal"`

	// MinPrice Minimum price order.
	MinPrice string `json:"minPrice"`

	// MinTotal Minimum order size in Quote.
	MinTotal string `json:"minTotal"`

	// OrderbookAsk Ask price of ticker.
	OrderbookAsk string `json:"orderbook_ask"`

	// OrderbookBid Bid price of ticker.
	OrderbookBid string `json:"orderbook_bid"`

	// OrderbookLast Last price of ticker.
	OrderbookLast string `json:"orderbook_last"`

	// OrderbookPriceCurrency Currency price of ticker.
	OrderbookPriceCurrency string `json:"orderbook_price_currency"`

	// PriceStep The minimum step for changing the price.
	PriceStep string `json:"priceStep"`

	// StrategyName The name of trading strategy.
	StrategyName string `json:"strategy_name"`
}

// Deal A single DCA‐bot deal, with all its execution and P/L details.
type Deal struct {
	// AccountId Unique 3Commas ID for the exchange account used.
	AccountId int `json:"account_id"`

	// AccountName The name of the exchange account, as set by the user.
	AccountName string `json:"account_name"`

	// ActiveManualSafetyOrders Number of active manually‐triggered safety orders.
	ActiveManualSafetyOrders int `json:"active_manual_safety_orders"`

	// ActiveSafetyOrdersCount Number of safety orders the bot may place concurrently.
	ActiveSafetyOrdersCount int `json:"active_safety_orders_count"`

	// ActualProfit Realized P/L after execution.
	ActualProfit nullable.Nullable[string] `json:"actual_profit"`

	// ActualProfitPercentage Realized profit percentage.
	ActualProfitPercentage string `json:"actual_profit_percentage"`

	// ActualUsdProfit Realized P/L in USD.
	ActualUsdProfit nullable.Nullable[string] `json:"actual_usd_profit"`

	// AddFundable Whether adding funds is allowed.
	AddFundable bool `json:"add_fundable"`

	// BaseOrderAveragePrice Average price of the base order.
	BaseOrderAveragePrice string `json:"base_order_average_price"`

	// BaseOrderVolume Volume of the base order.
	BaseOrderVolume string `json:"base_order_volume"`

	// BaseOrderVolumeType Volume type of the base order.
	BaseOrderVolumeType string `json:"base_order_volume_type"`

	// BotEvents Log of bot events for this deal.
	BotEvents []struct {
		// CreatedAt When the event occurred.
		CreatedAt *time.Time `json:"created_at,omitempty"`

		// Message Event description.
		Message *string `json:"message,omitempty"`
	} `json:"bot_events"`

	// BotId Unique 3Commas ID for the DCA Bot that opened this deal.
	BotId int `json:"bot_id"`

	// BotName DCA Bot name specified by the user.
	BotName string `json:"bot_name"`

	// BoughtAmount Amount of asset bought.
	BoughtAmount string `json:"bought_amount"`

	// BoughtAveragePrice Average price of the buy.
	BoughtAveragePrice string `json:"bought_average_price"`

	// BoughtVolume Quote‐currency volume spent.
	BoughtVolume string `json:"bought_volume"`

	// Cancellable Whether this deal can still be canceled.
	Cancellable bool `json:"cancellable?"`

	// CloseStrategyList Custom close strategies applied.
	CloseStrategyList []map[string]interface{} `json:"close_strategy_list"`

	// ClosedAt When the Deal was closed, or `null` if still open.
	ClosedAt nullable.Nullable[time.Time] `json:"closed_at"`

	// CompletedManualSafetyOrdersCount Number of manually‐triggered safety orders that have completed.
	CompletedManualSafetyOrdersCount int `json:"completed_manual_safety_orders_count"`

	// CompletedSafetyOrdersCount How many safety orders have already been filled.
	CompletedSafetyOrdersCount int `json:"completed_safety_orders_count"`

	// CreatedAt When the Deal was created (ISO 8601).
	CreatedAt time.Time `json:"created_at"`

	// CurrentActiveSafetyOrders Currently active safety orders.
	CurrentActiveSafetyOrders int `json:"current_active_safety_orders"`

	// CurrentActiveSafetyOrdersCount Currently active safety orders (including manual).
	CurrentActiveSafetyOrdersCount int `json:"current_active_safety_orders_count"`

	// CurrentPrice Latest market price.
	CurrentPrice string `json:"current_price"`

	// DealHasError Indicates whether this Deal has encountered any errors.
	DealHasError bool `json:"deal_has_error"`

	// ErrorMessage Error message if the deal failed.
	ErrorMessage nullable.Nullable[string] `json:"error_message"`

	// FinalProfit Net P/L (in profit currency).
	FinalProfit string `json:"final_profit"`

	// FinalProfitPercentage Net P/L percentage.
	FinalProfitPercentage string `json:"final_profit_percentage"`

	// Finished Whether this Deal has finished (`true`) or is still in progress (`false`).
	Finished bool `json:"finished?"`

	// FromCurrency Quote currency code.
	FromCurrency   string `json:"from_currency"`
	FromCurrencyId *int   `json:"from_currency_id,omitempty"`

	// Id Unique 3Commas ID for this Deal entity.
	Id int `json:"id"`

	// LeverageCustomValue User‐set leverage value.
	LeverageCustomValue nullable.Nullable[string] `json:"leverage_custom_value"`

	// LeverageType Leverage mode (`cross`, `isolated`, or `not_specified`).
	LeverageType string `json:"leverage_type"`

	// LocalizedStatus Human‐readable status.
	LocalizedStatus string `json:"localized_status"`

	// MarketType Exchange market type (`spot` or `futures`).
	MarketType string `json:"market_type"`

	// MartingaleStepCoefficient Martingale step multiplier.
	MartingaleStepCoefficient string `json:"martingale_step_coefficient"`

	// MartingaleVolumeCoefficient Martingale volume multiplier.
	MartingaleVolumeCoefficient string `json:"martingale_volume_coefficient"`

	// MaxSafetyOrders Maximum number of safety orders allowed for this deal.
	MaxSafetyOrders int `json:"max_safety_orders"`

	// MinProfitPercentage Minimum profit % for TP close strategy.
	MinProfitPercentage string `json:"min_profit_percentage"`

	// MinProfitType Basis for minimum profit calculation.
	MinProfitType nullable.Nullable[string] `json:"min_profit_type"`

	// Note Optional user note.
	Note nullable.Nullable[string] `json:"note"`

	// OrderbookPriceCurrency Currency used for orderbook quotes.
	OrderbookPriceCurrency string `json:"orderbook_price_currency"`

	// Pair Trading pair in 3Commas format.
	Pair string `json:"pair"`

	// PanicSellable Whether this deal can still be closed at market price.
	PanicSellable bool `json:"panic_sellable?"`

	// ProfitCurrency Currency for profit calculation.
	ProfitCurrency string `json:"profit_currency"`

	// SafetyOrderStepPercentage Price deviation (%) between safety orders.
	SafetyOrderStepPercentage string `json:"safety_order_step_percentage"`

	// SafetyOrderVolume Size of each safety order.
	SafetyOrderVolume string `json:"safety_order_volume"`

	// SafetyOrderVolumeType Volume type for safety orders (e.g. `quote_currency`, `base_currency`, `percent`).
	SafetyOrderVolumeType string `json:"safety_order_volume_type"`

	// SafetyStrategyList Custom strategies for safety orders.
	SafetyStrategyList []map[string]interface{} `json:"safety_strategy_list"`

	// SlToBreakevenData Breakeven config (e.g. `{ "upper_breakeven_limit": 1 }`).
	SlToBreakevenData nullable.Nullable[map[string]interface{}] `json:"sl_to_breakeven_data"`

	// SlToBreakevenEnabled Move-to-Breakeven feature enabled.
	SlToBreakevenEnabled bool `json:"sl_to_breakeven_enabled"`

	// SmartTradeConvertable Whether this deal can be converted to a SmartTrade.
	SmartTradeConvertable bool `json:"smart_trade_convertable"`

	// SoldAmount Amount of asset sold.
	SoldAmount string `json:"sold_amount"`

	// SoldAveragePrice Average sell price.
	SoldAveragePrice string `json:"sold_average_price"`

	// SoldVolume Quote‐currency volume received from sells.
	SoldVolume string `json:"sold_volume"`

	// Status Deal status
	Status DealStatus `json:"status"`

	// StopLossPercentage Stop-Loss trigger percentage.
	StopLossPercentage string `json:"stop_loss_percentage"`

	// StopLossPrice SL trigger price.
	StopLossPrice string `json:"stop_loss_price"`

	// StopLossTimeoutEnabled Whether Stop-Loss timeout is enabled.
	StopLossTimeoutEnabled bool `json:"stop_loss_timeout_enabled"`

	// StopLossTimeoutInSeconds Duration (s) of Stop-Loss timeout.
	StopLossTimeoutInSeconds int `json:"stop_loss_timeout_in_seconds"`

	// StopLossType What action occurs on Stop-Loss.
	StopLossType string `json:"stop_loss_type"`

	// TakeProfit Take Profit percentage, or `null` if using steps.
	TakeProfit nullable.Nullable[string] `json:"take_profit"`

	// TakeProfitPrice TP trigger price (single‐condition bots).
	TakeProfitPrice string `json:"take_profit_price"`

	// TakeProfitSteps If using TP steps, the details of each step.
	TakeProfitSteps []struct {
		// AmountPercentage % of base order volume for this TP step.
		AmountPercentage *float32 `json:"amount_percentage,omitempty"`

		// Editable Whether this step can still be edited.
		Editable *bool `json:"editable,omitempty"`

		// ExecutionTimestamp When this TP step executed, or `null`.
		ExecutionTimestamp nullable.Nullable[time.Time] `json:"execution_timestamp,omitempty"`

		// Id Step index.
		Id *int `json:"id,omitempty"`

		// InitialAmount Volume allocated for this TP step.
		InitialAmount *string `json:"initial_amount,omitempty"`

		// PanicSellable Whether this TP step can be closed at market.
		PanicSellable *bool `json:"panic_sellable,omitempty"`

		// Price Trigger price for this TP step.
		Price *string `json:"price,omitempty"`

		// ProfitPercentage % profit target for this TP step.
		ProfitPercentage *float32 `json:"profit_percentage,omitempty"`

		// Status Current status of this TP step.
		Status *string `json:"status,omitempty"`

		// TradeId 3Commas Trade entity ID.
		TradeId *int `json:"trade_id,omitempty"`
	} `json:"take_profit_steps"`

	// TakeProfitType Basis for TP calculation
	TakeProfitType DealTakeProfitType `json:"take_profit_type"`

	// ToCurrency Base currency code.
	ToCurrency   string `json:"to_currency"`
	ToCurrencyId *int   `json:"to_currency_id,omitempty"`

	// TrailingEnabled Trailing Take Profit enabled.
	TrailingEnabled bool `json:"trailing_enabled"`

	// TslEnabled Trailing Stop Loss enabled.
	TslEnabled bool `json:"tsl_enabled"`

	// Type The type of entity.
	Type string `json:"type"`

	// UpdatedAt When the Deal was last updated (ISO 8601).
	UpdatedAt time.Time `json:"updated_at"`

	// UsdFinalProfit Net P/L expressed in USD.
	UsdFinalProfit string `json:"usd_final_profit"`
}

// DealStatus Deal status
type DealStatus string

// DealTakeProfitType Basis for TP calculation
type DealTakeProfitType string

// DealDataForAddingFundsResponse defines model for DealDataForAddingFundsResponse.
type DealDataForAddingFundsResponse struct {
	// AccountId ID of the exchange account entity where this DCA Bot's deal was created.
	AccountId *int `json:"account_id,omitempty"`

	// AccountType Specifies the type of account.
	AccountType *string `json:"account_type,omitempty"`

	// AddingFundsCurrency Currency for additional funds.
	AddingFundsCurrency *string `json:"adding_funds_currency,omitempty"`

	// AvailableAmount The amount of quote currency available for trading.
	AvailableAmount *string `json:"available_amount,omitempty"`

	// BaseCurrency The base currency in the trading pair.
	BaseCurrency *string `json:"base_currency,omitempty"`

	// DealType Indicates the type of deal being executed: long or short.
	DealType *string `json:"deal_type,omitempty"`

	// IsContract Specifies if the trading instrument is a contract.
	IsContract *bool `json:"is_contract,omitempty"`

	// LeverageCustomValue The custom leverage value, if specified.
	LeverageCustomValue nullable.Nullable[string] `json:"leverage_custom_value,omitempty"`

	// LeverageType Type of leverage applied for this Deal.
	LeverageType *string `json:"leverage_type,omitempty"`

	// Limit The limit price for buy or sell orders.
	Limit  *string                `json:"limit,omitempty"`
	Limits *ExchangeTradingLimits `json:"limits,omitempty"`

	// MarketBuyMinTotal The minimum total amount for market buy orders.
	MarketBuyMinTotal *string `json:"market_buy_min_total,omitempty"`

	// MarketSupported Indicates if market orders are supported for this pair.
	MarketSupported *bool `json:"market_supported,omitempty"`

	// MinLotSize The minimum amount of the base currency that can be traded per order.
	MinLotSize *string `json:"min_lot_size,omitempty"`

	// OrderbookPrice The current price from the exchange's order book for the pair.
	OrderbookPrice *string `json:"orderbook_price,omitempty"`

	// OrderbookPriceCurrency Currency used for the order book price.
	OrderbookPriceCurrency *string `json:"orderbook_price_currency,omitempty"`

	// Pair Trading pair in 3Commas format.
	Pair *string `json:"pair,omitempty"`

	// PricePerOneUnitStrategyName The name of the strategy used to determine the price per unit.
	PricePerOneUnitStrategyName *string `json:"price_per_one_unit_strategy_name,omitempty"`

	// QuoteCurrency The quote currency in the trading pair.
	QuoteCurrency *string `json:"quote_currency,omitempty"`

	// StopLossPrice The price set to trigger a stop loss for the bot's deals.
	StopLossPrice nullable.Nullable[string] `json:"stop_loss_price,omitempty"`

	// TakeProfitPrice The set price at which to take profit for the bot's deals.
	TakeProfitPrice *string `json:"take_profit_price,omitempty"`
}

// DealUpdateRequest Parameters for editing an existing DCA Bot deal.
type DealUpdateRequest struct {
	// ActiveSafetyOrdersCount Number of Safety Orders placed in advance on the exchange order book.
	ActiveSafetyOrdersCount *int `json:"active_safety_orders_count,omitempty"`

	// CloseTimeout Seconds after which the deal will auto-close.
	CloseTimeout *int `json:"close_timeout,omitempty"`

	// MaxSafetyOrders Maximum total number of Safety Orders for this deal.
	MaxSafetyOrders *int `json:"max_safety_orders,omitempty"`

	// MinProfitPercentage Minimum profit percentage required to complete the deal.
	MinProfitPercentage *float32 `json:"min_profit_percentage,omitempty"`

	// Note Optional user-defined note for this deal.
	Note *string `json:"note,omitempty"`

	// ProfitCurrency Currency used to calculate profit (`quote_currency` or `base_currency`).
	ProfitCurrency *DealUpdateRequestProfitCurrency `json:"profit_currency,omitempty"`

	// SlToBreakevenData Upper limit to which stop loss will move when breakeven is activated.
	SlToBreakevenData *struct {
		UpperBreakevenLimit *float32 `json:"upper_breakeven_limit,omitempty"`
	} `json:"sl_to_breakeven_data,omitempty"`

	// SlToBreakevenEnabled Enable Move to Breakeven (requires at least two TP steps).
	SlToBreakevenEnabled *bool `json:"sl_to_breakeven_enabled,omitempty"`

	// StopLossPercentage Percentage drop from TP target to trigger a Stop Loss market order.
	StopLossPercentage *float32 `json:"stop_loss_percentage,omitempty"`

	// StopLossTimeoutEnabled Enable timeout before Stop Loss executes.
	StopLossTimeoutEnabled *bool `json:"stop_loss_timeout_enabled,omitempty"`

	// StopLossTimeoutInSeconds Timeout value in seconds; required if stop_loss_timeout_enabled is true.
	StopLossTimeoutInSeconds *int `json:"stop_loss_timeout_in_seconds,omitempty"`

	// StopLossType Action after Stop Loss triggers.
	StopLossType *DealUpdateRequestStopLossType `json:"stop_loss_type,omitempty"`

	// TakeProfit Percentage value for the bot’s Take Profit. Must be 0 if using multiple take_profit_steps.
	TakeProfit *float32 `json:"take_profit,omitempty"`

	// TakeProfitSteps Multiple steps with conditions for Taking Profit in this deal.
	TakeProfitSteps *[]TakeProfitStep `json:"take_profit_steps,omitempty"`

	// TakeProfitType Take Profit order type for this deal.
	TakeProfitType DealUpdateRequestTakeProfitType `json:"take_profit_type"`

	// TrailingEnabled Enable trailing for Take Profit.
	TrailingEnabled *bool `json:"trailing_enabled,omitempty"`

	// TslEnabled Enable trailing for Stop Loss.
	TslEnabled *bool `json:"tsl_enabled,omitempty"`
}

// DealUpdateRequestProfitCurrency Currency used to calculate profit (`quote_currency` or `base_currency`).
type DealUpdateRequestProfitCurrency string

// DealUpdateRequestStopLossType Action after Stop Loss triggers.
type DealUpdateRequestStopLossType string

// DealUpdateRequestTakeProfitType Take Profit order type for this deal.
type DealUpdateRequestTakeProfitType string

// DealsStats defines model for DealsStats.
type DealsStats struct {
	// Active The number of currently active deals.
	Active *int `json:"active,omitempty"`

	// ActiveDealsBtcProfit The current profit or loss from active deals in BTC.
	ActiveDealsBtcProfit *string `json:"active_deals_btc_profit,omitempty"`

	// ActiveDealsUsdProfit The current profit or loss from active deals in USD.
	ActiveDealsUsdProfit *string `json:"active_deals_usd_profit,omitempty"`

	// BtcFundsLockedInActiveDeals The total funds currently locked in active deals, in BTC.
	BtcFundsLockedInActiveDeals *string `json:"btc_funds_locked_in_active_deals,omitempty"`

	// Completed The total number of completed deals.
	Completed *int `json:"completed,omitempty"`

	// CompletedDealsBtcProfit The total profit from completed deals in BTC.
	CompletedDealsBtcProfit *string `json:"completed_deals_btc_profit,omitempty"`

	// CompletedDealsUsdProfit The total profit from completed deals in USD.
	CompletedDealsUsdProfit *string `json:"completed_deals_usd_profit,omitempty"`

	// FromCurrencyIsDollars Shows whether the base currency for profit calculation is USD.
	FromCurrencyIsDollars *bool `json:"from_currency_is_dollars,omitempty"`

	// FundsLockedInActiveDeals The total funds currently locked in active deals, in USD.
	FundsLockedInActiveDeals *string `json:"funds_locked_in_active_deals,omitempty"`

	// PanicSold The number of deals closed at market price.
	PanicSold *int `json:"panic_sold,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Error Short error code
	Error string `json:"error"`

	// ErrorAttributes Validation errors keyed by field name
	ErrorAttributes *map[string][]string `json:"error_attributes,omitempty"`

	// ErrorDescription Human-readable error message
	ErrorDescription *string `json:"error_description,omitempty"`
}

// ExchangeTradingLimits defines model for ExchangeTradingLimits.
type ExchangeTradingLimits struct {
	// LotStep Lot size step increment.
	LotStep *string `json:"lotStep,omitempty"`

	// MarketBuyMinTotal Minimum total amount for market buy orders.
	MarketBuyMinTotal *string `json:"marketBuyMinTotal,omitempty"`

	// MaxLotSize Maximum lot size for orders.
	MaxLotSize *string `json:"maxLotSize,omitempty"`

	// MaxMarketBuyAmount Maximum order size in base currency for market buy.
	MaxMarketBuyAmount *string `json:"maxMarketBuyAmount,omitempty"`

	// MaxMarketSellAmount Maximum order size in base currency for market sell.
	MaxMarketSellAmount *string `json:"maxMarketSellAmount,omitempty"`

	// MaxPrice Maximum price.
	MaxPrice *string `json:"maxPrice,omitempty"`

	// MinLotSize The minimum lot size for order in base currency.
	MinLotSize *string `json:"minLotSize,omitempty"`

	// MinMarketBuyAmount Minimum order size in base currency for market buy.
	MinMarketBuyAmount *string `json:"minMarketBuyAmount,omitempty"`

	// MinMarketSellAmount Minimum order size in base currency for market sell.
	MinMarketSellAmount *string `json:"minMarketSellAmount,omitempty"`

	// MinPrice Minimum price.
	MinPrice *string `json:"minPrice,omitempty"`

	// MinTotal Minimum total order size in quote currency.
	MinTotal *string `json:"minTotal,omitempty"`

	// PriceMultiplierDown Multiplier applied to decrease the price.
	PriceMultiplierDown *string `json:"priceMultiplierDown,omitempty"`

	// PriceMultiplierUp Multiplier applied to increase the price.
	PriceMultiplierUp *string `json:"priceMultiplierUp,omitempty"`

	// PriceStep The minimum step for changing the price.
	PriceStep *string `json:"priceStep,omitempty"`
}

// FormField defines model for FormField.
type FormField struct {
	// Field The parameter needed to connect a new exchange account.
	Field string `json:"field"`

	// LocalizedName Display name of the field, localized for user convenience.
	LocalizedName string `json:"localized_name"`
}

// FormFields defines model for FormFields.
type FormFields struct {
	Optional []FormField `json:"optional"`
	Required []FormField `json:"required"`
}

// LeverageData defines model for LeverageData.
type LeverageData struct {
	// AvailableLeverageValues Available leverage values for settings for this pair and exchange.
	AvailableLeverageValues *[]string `json:"available_leverage_values,omitempty"`

	// CanSetLeverageValue Indicates whether a custom leverage value can be set.
	CanSetLeverageValue *bool `json:"can_set_leverage_value,omitempty"`

	// Code The type of leverage available.
	Code *string `json:"code,omitempty"`

	// MaxLeverage The maximum leverage value allowed for this contract.
	MaxLeverage *string `json:"max_leverage,omitempty"`

	// Name Name of the leverage option available for this contract.
	Name *string `json:"name,omitempty"`

	// Valid Contains minimum and maximum leverage value that can be applied for this pair.
	Valid *struct {
		// Max The maximum leverage value that can be applied to this contract.
		Max string `json:"max"`

		// Min The minimum leverage value that can be applied to this contract.
		Min float32 `json:"min"`
	} `json:"valid,omitempty"`
}

// MarketListItem defines model for MarketListItem.
type MarketListItem struct {
	// AvailableConnectionFlows Available exchange connection types in 3Commas.
	AvailableConnectionFlows []MarketListItemAvailableConnectionFlows `json:"available_connection_flows"`

	// FastConnectActionName Name of the exchange for fast connection option in the 3Commas system.
	FastConnectActionName string     `json:"fast_connect_action_name"`
	FormFields            FormFields `json:"form_fields"`

	// HelpLink Public URL to the help page with detailed instructions on connecting the exchange.
	HelpLink string `json:"help_link"`

	// MarketCode 3Commas exchange code entity.
	MarketCode string `json:"market_code"`

	// MarketIcon URL link to the icon for this exchange.
	MarketIcon string `json:"market_icon"`

	// MarketName Name of the exchange in the 3Commas system.
	MarketName string `json:"market_name"`

	// MarketUrl Referral link to the exchange website.
	MarketUrl string `json:"market_url"`

	// ThirdPartyAllowed Indicates whether this exchange allows connection by third-party apps.
	ThirdPartyAllowed bool `json:"third_party_allowed"`

	// TrustedIps List of IP addresses that need to be whitelisted on the exchange's website for 3Commas to work with the exchange.
	TrustedIps []string `json:"trusted_ips"`

	// TrustedIpsInputType Input type for trusted IP addresses.
	TrustedIpsInputType string `json:"trusted_ips_input_type"`
}

// MarketListItemAvailableConnectionFlows defines model for MarketListItem.AvailableConnectionFlows.
type MarketListItemAvailableConnectionFlows string

// MarketOrder defines model for MarketOrder.
type MarketOrder struct {
	// AveragePrice The weighted average price at which the asset was bought or sold during execution.
	AveragePrice string `json:"average_price"`

	// Cancellable Indicates whether this trade can be canceled.
	Cancellable bool `json:"cancellable"`

	// CreatedAt ISO 8601 datetime string of when this Trade entity was created.
	CreatedAt time.Time `json:"created_at"`

	// DealOrderType The type of the order to be created by this trade.
	DealOrderType MarketOrderDealOrderType `json:"deal_order_type"`

	// OrderId Unique 3Commas Trade entity ID.
	OrderId string `json:"order_id"`

	// OrderType The side of the order to be created by this trade.
	OrderType MarketOrderOrderType `json:"order_type"`

	// Quantity Total quantity of the asset in this order.
	Quantity string `json:"quantity"`

	// QuantityRemaining Remaining quantity of the asset left to be filled in this order.
	QuantityRemaining string `json:"quantity_remaining"`

	// Rate Price per unit of the asset in the order.
	Rate string `json:"rate"`

	// StatusString 3Commas status for this Trade.
	// - `Active` the trade is currently open, waiting to be filled
	// - `Filled` the trade has been fully executed
	// - `Finished` the trade process is complete
	// - `Cancelled` the trade was canceled before it could be fully executed
	// - `Inactive` (undocumented but shown in Example)
	StatusString MarketOrderStatusString `json:"status_string"`

	// Total Total value of the order based on quantity and rate.
	Total string `json:"total"`

	// UpdatedAt ISO 8601 datetime string of when this Trade entity was created.
	UpdatedAt time.Time `json:"updated_at"`
}

// MarketOrderDealOrderType The type of the order to be created by this trade.
type MarketOrderDealOrderType string

// MarketOrderOrderType The side of the order to be created by this trade.
type MarketOrderOrderType string

// MarketOrderStatusString 3Commas status for this Trade.
// - `Active` the trade is currently open, waiting to be filled
// - `Filled` the trade has been fully executed
// - `Finished` the trade process is complete
// - `Cancelled` the trade was canceled before it could be fully executed
// - `Inactive` (undocumented but shown in Example)
type MarketOrderStatusString string

// Pairs Trading pair(s) in 3Commas format.
type Pairs = []string

// PairsResponse Response wrapper for a list of trading pairs
type PairsResponse struct {
	// Pairs Trading pair(s) in 3Commas format.
	Pairs Pairs `json:"pairs"`
}

// ProfitByDay defines model for ProfitByDay.
type ProfitByDay = []struct {
	Profit struct {
		Btc *string `json:"btc,omitempty"`
		Usd *string `json:"usd,omitempty"`
	} `json:"profit"`
	SDate         openapi_types.Date `json:"s_date"`
	UnixTimestamp int                `json:"unix_timestamp"`
}

// StrategyConfig Configuration object for an individual strategy in strategy_list, close_strategy_list, or safety_strategy_list.
type StrategyConfig struct {
	// Options Strategy-specific parameters (keys depend on the chosen strategy; see examples below).
	Options *map[string]interface{} `json:"options,omitempty"`

	// Strategy Identifier of the strategy
	Strategy *StrategyConfigStrategy `json:"strategy,omitempty"`
}

// StrategyConfigStrategy Identifier of the strategy
type StrategyConfigStrategy string

// StrategyDefinition defines model for StrategyDefinition.
type StrategyDefinition struct {
	// AccountsWhitelist List of account types supported by this strategy.
	AccountsWhitelist nullable.Nullable[[]string] `json:"accounts_whitelist,omitempty"`

	// Beta Indicates if the strategy is in beta.
	Beta bool `json:"beta"`

	// Name Human-readable name of the strategy.
	Name string `json:"name"`

	// Options Strategy-specific parameters.
	Options nullable.Nullable[map[string]interface{}] `json:"options,omitempty"`

	// Payed Indicates if the strategy requires payment.
	Payed bool `json:"payed"`

	// StrategyType Type of strategy (e.g., signal, indicator).
	StrategyType string `json:"strategy_type"`
}

// StrategyList defines model for StrategyList.
type StrategyList map[string]StrategyDefinition

// TakeProfitStep defines model for TakeProfitStep.
type TakeProfitStep struct {
	// AmountPercentage The percentage of the base order volume to be allocated for this Take Profit step.
	AmountPercentage *int `json:"amount_percentage,omitempty"`

	// Id Step number of Take Profit.
	Id *int `json:"id,omitempty"`

	// ProfitPercentage The specific profit percentage applied to the volume of units for this Take Profit step.
	ProfitPercentage *int `json:"profit_percentage,omitempty"`
}

// UpdateBotRequest defines model for UpdateBotRequest.
type UpdateBotRequest = BotEntity

// ValidateResponse defines model for ValidateResponse.
type ValidateResponse struct {
	// Valid Indicates whether the provided API credentials are valid.
	Valid bool `json:"valid"`
}

// AccountQueryId defines model for AccountQueryId.
type AccountQueryId = int

// BotPathId defines model for BotPathId.
type BotPathId = int

// DealPathId defines model for DealPathId.
type DealPathId = int

// TradeQueryId defines model for TradeQueryId.
type TradeQueryId = int

// BadRequest defines model for BadRequest.
type BadRequest = ErrorResponse

// BotCreated defines model for BotCreated.
type BotCreated = Bot

// BotOK defines model for BotOK.
type BotOK = Bot

// BotUpdated defines model for BotUpdated.
type BotUpdated = Bot

// DealResponse A single DCA‐bot deal, with all its execution and P/L details.
type DealResponse = Deal

// Forbidden defines model for Forbidden.
type Forbidden = ErrorResponse

// GatewayTimeout defines model for GatewayTimeout.
type GatewayTimeout = ErrorResponse

// IPAutoBanned defines model for IPAutoBanned.
type IPAutoBanned = ErrorResponse

// InternalServerError defines model for InternalServerError.
type InternalServerError = ErrorResponse

// NotFound defines model for NotFound.
type NotFound = ErrorResponse

// RateLimitExceeded defines model for RateLimitExceeded.
type RateLimitExceeded = ErrorResponse

// Unauthorized defines model for Unauthorized.
type Unauthorized = ErrorResponse

// GetCurrencyRatesParams defines parameters for GetCurrencyRates.
type GetCurrencyRatesParams struct {
	// MarketCode Unique exchange code in the 3Commas system. Use endpoint Supported markets list to get value for parameter market_code.
	MarketCode int `form:"market_code" json:"market_code"`

	// Pair Trading pair in 3Commas format. Use endpoints All Market Pairs to get value for parameter pair in 3Commas format.
	Pair string `form:"pair" json:"pair"`

	// LimitType Defines the type of trading limits returned based on the selected trading tool bot or smart_trade. If set to bot, the response includes trading limits specific to DCA, Signal and Grid Bots. If set to smart_trade, the response includes trading limits for SmartTrade.
	LimitType *GetCurrencyRatesParamsLimitType `form:"limit_type,omitempty" json:"limit_type,omitempty"`
}

// GetCurrencyRatesParamsLimitType defines parameters for GetCurrencyRates.
type GetCurrencyRatesParamsLimitType string

// GetCurrencyRatesWithLeverageDataParams defines parameters for GetCurrencyRatesWithLeverageData.
type GetCurrencyRatesWithLeverageDataParams struct {
	// MarketCode Unique exchange code in the 3Commas system. Use endpoint Supported markets list to get value for parameter market_code.
	MarketCode int `form:"market_code" json:"market_code"`

	// Pair Trading pair in 3Commas format. Use endpoints All Market Pairs to get value for parameter pair in 3Commas format.
	Pair string `form:"pair" json:"pair"`
}

// GetMarketPairsParams defines parameters for GetMarketPairs.
type GetMarketPairsParams struct {
	// MarketCode Unique exchange code in the 3Commas system. Use the “Supported markets list” endpoint to get valid values.
	MarketCode string `form:"market_code" json:"market_code"`
}

// ListBotsParams defines parameters for ListBots.
type ListBotsParams struct {
	// AccountId Unique 3Commas ID of the exchange account entity. Use the List of connected exchanges and wallets endpoint to retrieve the value for the account_id parameter.
	AccountId *AccountQueryId `form:"account_id,omitempty" json:"account_id,omitempty"`

	// Strategy Filters bots by trading strategy type.
	Strategy *ListBotsParamsStrategy `form:"strategy,omitempty" json:"strategy,omitempty"`

	// OrderDirection Sets the direction of ordering.
	OrderDirection *ListBotsParamsOrderDirection `form:"order_direction,omitempty" json:"order_direction,omitempty"`

	// Limit Limits the number of records returned (max 100).
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Skips the first N records in the results.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// From Returns entities created after a specific timestamp in RFC 3339.
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// Scope Filters bots by their status.
	Scope *ListBotsParamsScope `form:"scope,omitempty" json:"scope,omitempty"`

	// SortBy Specifies the field used to order the results.
	SortBy *ListBotsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Quote Filters by quote currency.
	Quote *string `form:"quote,omitempty" json:"quote,omitempty"`
}

// ListBotsParamsStrategy defines parameters for ListBots.
type ListBotsParamsStrategy string

// ListBotsParamsOrderDirection defines parameters for ListBots.
type ListBotsParamsOrderDirection string

// ListBotsParamsScope defines parameters for ListBots.
type ListBotsParamsScope string

// ListBotsParamsSortBy defines parameters for ListBots.
type ListBotsParamsSortBy string

// GetBotsStatsParams defines parameters for GetBotsStats.
type GetBotsStatsParams struct {
	// AccountId Unique 3Commas ID of the exchange account entity. Use the List of connected exchanges and wallets endpoint to retrieve the value for the account_id parameter.
	AccountId *AccountQueryId `form:"account_id,omitempty" json:"account_id,omitempty"`

	// BotId Filters entities linked to the specified DCA Bot.
	BotId *int `form:"bot_id,omitempty" json:"bot_id,omitempty"`
}

// GetBotsStatsByDateParams defines parameters for GetBotsStatsByDate.
type GetBotsStatsByDateParams struct {
	// AccountId Unique 3Commas ID of the exchange account entity. Use the List of connected exchanges and wallets endpoint to retrieve the value for the account_id parameter.
	AccountId *AccountQueryId `form:"account_id,omitempty" json:"account_id,omitempty"`

	// BotId Filters entities linked to the specified DCA Bot.
	BotId *int `form:"bot_id,omitempty" json:"bot_id,omitempty"`

	// Date Specific day for which profit data is requested for this bot or account.
	Date time.Time `form:"date" json:"date"`
}

// ListStrategiesParams defines parameters for ListStrategies.
type ListStrategiesParams struct {
	// AccountId Unique 3Commas ID of the exchange account entity. Use the List of connected exchanges and wallets endpoint to retrieve the value for the account_id parameter.
	AccountId *AccountQueryId `form:"account_id,omitempty" json:"account_id,omitempty"`

	// Type Specifies the strategy direction for the bot.
	Type *ListStrategiesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Strategy Specifies the type of strategy list.
	Strategy *ListStrategiesParamsStrategy `form:"strategy,omitempty" json:"strategy,omitempty"`
}

// ListStrategiesParamsType defines parameters for ListStrategies.
type ListStrategiesParamsType string

// ListStrategiesParamsStrategy defines parameters for ListStrategies.
type ListStrategiesParamsStrategy string

// UpdatePairsBlacklistParams defines parameters for UpdatePairsBlacklist.
type UpdatePairsBlacklistParams struct {
	// Pairs Trading pair(s) in 3Commas format. Use the endpoint All Market Pairs to get valid values.
	Pairs string `form:"pairs" json:"pairs"`
}

// GetProfitByDayParams defines parameters for GetProfitByDay.
type GetProfitByDayParams struct {
	// Days Specifies the number of days for which profit data is requested for this bot.
	Days *int `form:"days,omitempty" json:"days,omitempty"`
}

// GetBotParams defines parameters for GetBot.
type GetBotParams struct {
	// IncludeEvents Indicates whether to include information about events related to the entity.
	IncludeEvents bool `form:"include_events" json:"include_events"`
}

// ListDealsParams defines parameters for ListDeals.
type ListDealsParams struct {
	// BotId Filters by the unique ID of the 3Commas DCA Bot.
	BotId *int `form:"bot_id,omitempty" json:"bot_id,omitempty"`

	// AccountId Unique 3Commas ID of the exchange account entity. Use the List of connected exchanges and wallets endpoint to retrieve the value for the account_id parameter.
	AccountId *AccountQueryId `form:"account_id,omitempty" json:"account_id,omitempty"`

	// Limit Limits the number of records returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Skips the first N records in the results.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// From Returns entities created after a specific timestamp in RFC 3339.
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// To Returns entities created before a specific timestamp in RFC 3339.
	To *time.Time `form:"to,omitempty" json:"to,omitempty"`

	// Scope Filters deals by their status.
	Scope *ListDealsParamsScope `form:"scope,omitempty" json:"scope,omitempty"`

	// Order Specifies the field used to order the results.
	Order *ListDealsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderDirection Sets the direction of order: ASC or DESC.
	OrderDirection *ListDealsParamsOrderDirection `form:"order_direction,omitempty" json:"order_direction,omitempty"`

	// Base Filters by base currency.
	Base *string `form:"base,omitempty" json:"base,omitempty"`

	// Quote Filters by quote currency.
	Quote *string `form:"quote,omitempty" json:"quote,omitempty"`

	// Note Filters deals by note.
	Note *string `form:"note,omitempty" json:"note,omitempty"`
}

// ListDealsParamsScope defines parameters for ListDeals.
type ListDealsParamsScope string

// ListDealsParamsOrder defines parameters for ListDeals.
type ListDealsParamsOrder string

// ListDealsParamsOrderDirection defines parameters for ListDeals.
type ListDealsParamsOrderDirection string

// PanicSellDealStepParams defines parameters for PanicSellDealStep.
type PanicSellDealStepParams struct {
	// TradeId Unique 3Commas ID for the Trade entity within the deal that should be sold. Use the Get Deal endpoint to retrieve trade_id values.
	TradeId TradeQueryId `form:"trade_id" json:"trade_id"`
}

// CreateDcaBotJSONRequestBody defines body for CreateDcaBot for application/json ContentType.
type CreateDcaBotJSONRequestBody = CreateBotRequest

// CopyAndCreateBotJSONRequestBody defines body for CopyAndCreateBot for application/json ContentType.
type CopyAndCreateBotJSONRequestBody = CopyBotRequest

// UpdateBotJSONRequestBody defines body for UpdateBot for application/json ContentType.
type UpdateBotJSONRequestBody = UpdateBotRequest

// UpdateDealJSONRequestBody defines body for UpdateDeal for application/json ContentType.
type UpdateDealJSONRequestBody = DealUpdateRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Currency rates and limits
	// (GET /ver1/accounts/currency_rates)
	GetCurrencyRates(w http.ResponseWriter, r *http.Request, params GetCurrencyRatesParams)
	// Currency rates and limits with leverage data
	// (GET /ver1/accounts/currency_rates_with_leverage_data)
	GetCurrencyRatesWithLeverageData(w http.ResponseWriter, r *http.Request, params GetCurrencyRatesWithLeverageDataParams)
	// Supported markets list
	// (GET /ver1/accounts/market_list)
	GetMarketList(w http.ResponseWriter, r *http.Request)
	// All market pairs
	// (GET /ver1/accounts/market_pairs)
	GetMarketPairs(w http.ResponseWriter, r *http.Request, params GetMarketPairsParams)
	// Get the list of DCA Bots
	// (GET /ver1/bots)
	ListBots(w http.ResponseWriter, r *http.Request, params ListBotsParams)
	// Create DCA Bot
	// (POST /ver1/bots/create_bot)
	CreateDcaBot(w http.ResponseWriter, r *http.Request)
	// Get blacklist of pairs
	// (GET /ver1/bots/pairs_black_list)
	GetPairsBlacklist(w http.ResponseWriter, r *http.Request)
	// Get DCA Bot stats
	// (GET /ver1/bots/stats)
	GetBotsStats(w http.ResponseWriter, r *http.Request, params GetBotsStatsParams)
	// Get DCA Bot stats by date
	// (GET /ver1/bots/stats_by_date)
	GetBotsStatsByDate(w http.ResponseWriter, r *http.Request, params GetBotsStatsByDateParams)
	// Available strategy list
	// (GET /ver1/bots/strategy_list)
	ListStrategies(w http.ResponseWriter, r *http.Request, params ListStrategiesParams)
	// Add pairs to blacklist
	// (POST /ver1/bots/update_pairs_black_list)
	UpdatePairsBlacklist(w http.ResponseWriter, r *http.Request, params UpdatePairsBlacklistParams)
	// Cancel DCA Bot
	// (POST /ver1/bots/{bot_id}/cancel_all_deals)
	CancelAllDeals(w http.ResponseWriter, r *http.Request, botId BotPathId)
	// Copy DCA Bot
	// (POST /ver1/bots/{bot_id}/copy_and_create)
	CopyAndCreateBot(w http.ResponseWriter, r *http.Request, botId BotPathId)
	// DCA Bot deals stats
	// (GET /ver1/bots/{bot_id}/deals_stats)
	GetDealsStats(w http.ResponseWriter, r *http.Request, botId BotPathId)
	// Delete DCA Bot
	// (POST /ver1/bots/{bot_id}/delete)
	DeleteBot(w http.ResponseWriter, r *http.Request, botId BotPathId)
	// Disable DCA Bot
	// (POST /ver1/bots/{bot_id}/disable)
	DisableBot(w http.ResponseWriter, r *http.Request, botId BotPathId)
	// Enable DCA Bot
	// (POST /ver1/bots/{bot_id}/enable)
	EnableBot(w http.ResponseWriter, r *http.Request, botId BotPathId)
	// Close DCA Bot at market price
	// (POST /ver1/bots/{bot_id}/panic_sell_all_deals)
	PanicSellAllDeals(w http.ResponseWriter, r *http.Request, botId BotPathId)
	// Get DCA Bot profit data
	// (GET /ver1/bots/{bot_id}/profit_by_day)
	GetProfitByDay(w http.ResponseWriter, r *http.Request, botId BotPathId, params GetProfitByDayParams)
	// Get DCA Bot
	// (GET /ver1/bots/{bot_id}/show)
	GetBot(w http.ResponseWriter, r *http.Request, botId BotPathId, params GetBotParams)
	// Edit DCA Bot
	// (PATCH /ver1/bots/{bot_id}/update)
	UpdateBot(w http.ResponseWriter, r *http.Request, botId BotPathId)
	// Get list of deals
	// (GET /ver1/deals)
	ListDeals(w http.ResponseWriter, r *http.Request, params ListDealsParams)
	// Cancel deal
	// (POST /ver1/deals/{deal_id}/cancel)
	CancelDeal(w http.ResponseWriter, r *http.Request, dealId DealPathId)
	// Get info required to add funds
	// (GET /ver1/deals/{deal_id}/data_for_adding_funds)
	GetDealDataForAddingFunds(w http.ResponseWriter, r *http.Request, dealId DealPathId)
	// Get trades of deal
	// (GET /ver1/deals/{deal_id}/market_orders)
	GetTradesOfDeal(w http.ResponseWriter, r *http.Request, dealId DealPathId)
	// Close deal at market price
	// (POST /ver1/deals/{deal_id}/panic_sell)
	PanicSellDeal(w http.ResponseWriter, r *http.Request, dealId DealPathId)
	// Close one step in deal at market price
	// (POST /ver1/deals/{deal_id}/panic_sell_step)
	PanicSellDealStep(w http.ResponseWriter, r *http.Request, dealId DealPathId, params PanicSellDealStepParams)
	// Get deal
	// (GET /ver1/deals/{deal_id}/show)
	GetDeal(w http.ResponseWriter, r *http.Request, dealId DealPathId)
	// Update deal
	// (PATCH /ver1/deals/{deal_id}/update_deal)
	UpdateDeal(w http.ResponseWriter, r *http.Request, dealId int)
	// Test authentication
	// (GET /ver1/validate)
	ValidateAuthentication(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetCurrencyRates operation middleware
func (siw *ServerInterfaceWrapper) GetCurrencyRates(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCurrencyRatesParams

	// ------------- Required query parameter "market_code" -------------

	if paramValue := r.URL.Query().Get("market_code"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "market_code"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "market_code", r.URL.Query(), &params.MarketCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "market_code", Err: err})
		return
	}

	// ------------- Required query parameter "pair" -------------

	if paramValue := r.URL.Query().Get("pair"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "pair"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "pair", r.URL.Query(), &params.Pair)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pair", Err: err})
		return
	}

	// ------------- Optional query parameter "limit_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit_type", r.URL.Query(), &params.LimitType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit_type", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCurrencyRates(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCurrencyRatesWithLeverageData operation middleware
func (siw *ServerInterfaceWrapper) GetCurrencyRatesWithLeverageData(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCurrencyRatesWithLeverageDataParams

	// ------------- Required query parameter "market_code" -------------

	if paramValue := r.URL.Query().Get("market_code"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "market_code"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "market_code", r.URL.Query(), &params.MarketCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "market_code", Err: err})
		return
	}

	// ------------- Required query parameter "pair" -------------

	if paramValue := r.URL.Query().Get("pair"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "pair"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "pair", r.URL.Query(), &params.Pair)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pair", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCurrencyRatesWithLeverageData(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetMarketList operation middleware
func (siw *ServerInterfaceWrapper) GetMarketList(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMarketList(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetMarketPairs operation middleware
func (siw *ServerInterfaceWrapper) GetMarketPairs(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMarketPairsParams

	// ------------- Required query parameter "market_code" -------------

	if paramValue := r.URL.Query().Get("market_code"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "market_code"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "market_code", r.URL.Query(), &params.MarketCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "market_code", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMarketPairs(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListBots operation middleware
func (siw *ServerInterfaceWrapper) ListBots(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBotsParams

	// ------------- Optional query parameter "account_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "account_id", r.URL.Query(), &params.AccountId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account_id", Err: err})
		return
	}

	// ------------- Optional query parameter "strategy" -------------

	err = runtime.BindQueryParameter("form", true, false, "strategy", r.URL.Query(), &params.Strategy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "strategy", Err: err})
		return
	}

	// ------------- Optional query parameter "order_direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_direction", r.URL.Query(), &params.OrderDirection)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order_direction", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "scope" -------------

	err = runtime.BindQueryParameter("form", true, false, "scope", r.URL.Query(), &params.Scope)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "scope", Err: err})
		return
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", r.URL.Query(), &params.SortBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort_by", Err: err})
		return
	}

	// ------------- Optional query parameter "quote" -------------

	err = runtime.BindQueryParameter("form", true, false, "quote", r.URL.Query(), &params.Quote)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "quote", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListBots(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateDcaBot operation middleware
func (siw *ServerInterfaceWrapper) CreateDcaBot(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, APIKEYScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateDcaBot(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPairsBlacklist operation middleware
func (siw *ServerInterfaceWrapper) GetPairsBlacklist(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPairsBlacklist(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetBotsStats operation middleware
func (siw *ServerInterfaceWrapper) GetBotsStats(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBotsStatsParams

	// ------------- Optional query parameter "account_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "account_id", r.URL.Query(), &params.AccountId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account_id", Err: err})
		return
	}

	// ------------- Optional query parameter "bot_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "bot_id", r.URL.Query(), &params.BotId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bot_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBotsStats(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetBotsStatsByDate operation middleware
func (siw *ServerInterfaceWrapper) GetBotsStatsByDate(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBotsStatsByDateParams

	// ------------- Optional query parameter "account_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "account_id", r.URL.Query(), &params.AccountId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account_id", Err: err})
		return
	}

	// ------------- Optional query parameter "bot_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "bot_id", r.URL.Query(), &params.BotId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bot_id", Err: err})
		return
	}

	// ------------- Required query parameter "date" -------------

	if paramValue := r.URL.Query().Get("date"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "date"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBotsStatsByDate(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListStrategies operation middleware
func (siw *ServerInterfaceWrapper) ListStrategies(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListStrategiesParams

	// ------------- Optional query parameter "account_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "account_id", r.URL.Query(), &params.AccountId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account_id", Err: err})
		return
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	// ------------- Optional query parameter "strategy" -------------

	err = runtime.BindQueryParameter("form", true, false, "strategy", r.URL.Query(), &params.Strategy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "strategy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListStrategies(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdatePairsBlacklist operation middleware
func (siw *ServerInterfaceWrapper) UpdatePairsBlacklist(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdatePairsBlacklistParams

	// ------------- Required query parameter "pairs" -------------

	if paramValue := r.URL.Query().Get("pairs"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "pairs"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "pairs", r.URL.Query(), &params.Pairs)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pairs", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePairsBlacklist(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CancelAllDeals operation middleware
func (siw *ServerInterfaceWrapper) CancelAllDeals(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "bot_id" -------------
	var botId BotPathId

	err = runtime.BindStyledParameterWithOptions("simple", "bot_id", r.PathValue("bot_id"), &botId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bot_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CancelAllDeals(w, r, botId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CopyAndCreateBot operation middleware
func (siw *ServerInterfaceWrapper) CopyAndCreateBot(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "bot_id" -------------
	var botId BotPathId

	err = runtime.BindStyledParameterWithOptions("simple", "bot_id", r.PathValue("bot_id"), &botId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bot_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CopyAndCreateBot(w, r, botId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDealsStats operation middleware
func (siw *ServerInterfaceWrapper) GetDealsStats(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "bot_id" -------------
	var botId BotPathId

	err = runtime.BindStyledParameterWithOptions("simple", "bot_id", r.PathValue("bot_id"), &botId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bot_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDealsStats(w, r, botId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteBot operation middleware
func (siw *ServerInterfaceWrapper) DeleteBot(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "bot_id" -------------
	var botId BotPathId

	err = runtime.BindStyledParameterWithOptions("simple", "bot_id", r.PathValue("bot_id"), &botId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bot_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteBot(w, r, botId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DisableBot operation middleware
func (siw *ServerInterfaceWrapper) DisableBot(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "bot_id" -------------
	var botId BotPathId

	err = runtime.BindStyledParameterWithOptions("simple", "bot_id", r.PathValue("bot_id"), &botId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bot_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DisableBot(w, r, botId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// EnableBot operation middleware
func (siw *ServerInterfaceWrapper) EnableBot(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "bot_id" -------------
	var botId BotPathId

	err = runtime.BindStyledParameterWithOptions("simple", "bot_id", r.PathValue("bot_id"), &botId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bot_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EnableBot(w, r, botId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PanicSellAllDeals operation middleware
func (siw *ServerInterfaceWrapper) PanicSellAllDeals(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "bot_id" -------------
	var botId BotPathId

	err = runtime.BindStyledParameterWithOptions("simple", "bot_id", r.PathValue("bot_id"), &botId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bot_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PanicSellAllDeals(w, r, botId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetProfitByDay operation middleware
func (siw *ServerInterfaceWrapper) GetProfitByDay(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "bot_id" -------------
	var botId BotPathId

	err = runtime.BindStyledParameterWithOptions("simple", "bot_id", r.PathValue("bot_id"), &botId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bot_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProfitByDayParams

	// ------------- Optional query parameter "days" -------------

	err = runtime.BindQueryParameter("form", true, false, "days", r.URL.Query(), &params.Days)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "days", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProfitByDay(w, r, botId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetBot operation middleware
func (siw *ServerInterfaceWrapper) GetBot(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "bot_id" -------------
	var botId BotPathId

	err = runtime.BindStyledParameterWithOptions("simple", "bot_id", r.PathValue("bot_id"), &botId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bot_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBotParams

	// ------------- Required query parameter "include_events" -------------

	if paramValue := r.URL.Query().Get("include_events"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "include_events"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "include_events", r.URL.Query(), &params.IncludeEvents)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "include_events", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBot(w, r, botId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateBot operation middleware
func (siw *ServerInterfaceWrapper) UpdateBot(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "bot_id" -------------
	var botId BotPathId

	err = runtime.BindStyledParameterWithOptions("simple", "bot_id", r.PathValue("bot_id"), &botId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bot_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateBot(w, r, botId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListDeals operation middleware
func (siw *ServerInterfaceWrapper) ListDeals(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDealsParams

	// ------------- Optional query parameter "bot_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "bot_id", r.URL.Query(), &params.BotId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bot_id", Err: err})
		return
	}

	// ------------- Optional query parameter "account_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "account_id", r.URL.Query(), &params.AccountId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account_id", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", r.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	// ------------- Optional query parameter "scope" -------------

	err = runtime.BindQueryParameter("form", true, false, "scope", r.URL.Query(), &params.Scope)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "scope", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "order_direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_direction", r.URL.Query(), &params.OrderDirection)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order_direction", Err: err})
		return
	}

	// ------------- Optional query parameter "base" -------------

	err = runtime.BindQueryParameter("form", true, false, "base", r.URL.Query(), &params.Base)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "base", Err: err})
		return
	}

	// ------------- Optional query parameter "quote" -------------

	err = runtime.BindQueryParameter("form", true, false, "quote", r.URL.Query(), &params.Quote)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "quote", Err: err})
		return
	}

	// ------------- Optional query parameter "note" -------------

	err = runtime.BindQueryParameter("form", true, false, "note", r.URL.Query(), &params.Note)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "note", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListDeals(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CancelDeal operation middleware
func (siw *ServerInterfaceWrapper) CancelDeal(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deal_id" -------------
	var dealId DealPathId

	err = runtime.BindStyledParameterWithOptions("simple", "deal_id", r.PathValue("deal_id"), &dealId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deal_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CancelDeal(w, r, dealId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDealDataForAddingFunds operation middleware
func (siw *ServerInterfaceWrapper) GetDealDataForAddingFunds(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deal_id" -------------
	var dealId DealPathId

	err = runtime.BindStyledParameterWithOptions("simple", "deal_id", r.PathValue("deal_id"), &dealId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deal_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDealDataForAddingFunds(w, r, dealId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTradesOfDeal operation middleware
func (siw *ServerInterfaceWrapper) GetTradesOfDeal(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deal_id" -------------
	var dealId DealPathId

	err = runtime.BindStyledParameterWithOptions("simple", "deal_id", r.PathValue("deal_id"), &dealId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deal_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTradesOfDeal(w, r, dealId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PanicSellDeal operation middleware
func (siw *ServerInterfaceWrapper) PanicSellDeal(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deal_id" -------------
	var dealId DealPathId

	err = runtime.BindStyledParameterWithOptions("simple", "deal_id", r.PathValue("deal_id"), &dealId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deal_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PanicSellDeal(w, r, dealId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PanicSellDealStep operation middleware
func (siw *ServerInterfaceWrapper) PanicSellDealStep(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deal_id" -------------
	var dealId DealPathId

	err = runtime.BindStyledParameterWithOptions("simple", "deal_id", r.PathValue("deal_id"), &dealId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deal_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PanicSellDealStepParams

	// ------------- Required query parameter "trade_id" -------------

	if paramValue := r.URL.Query().Get("trade_id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "trade_id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "trade_id", r.URL.Query(), &params.TradeId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "trade_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PanicSellDealStep(w, r, dealId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDeal operation middleware
func (siw *ServerInterfaceWrapper) GetDeal(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deal_id" -------------
	var dealId DealPathId

	err = runtime.BindStyledParameterWithOptions("simple", "deal_id", r.PathValue("deal_id"), &dealId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deal_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDeal(w, r, dealId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateDeal operation middleware
func (siw *ServerInterfaceWrapper) UpdateDeal(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deal_id" -------------
	var dealId int

	err = runtime.BindStyledParameterWithOptions("simple", "deal_id", r.PathValue("deal_id"), &dealId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deal_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateDeal(w, r, dealId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ValidateAuthentication operation middleware
func (siw *ServerInterfaceWrapper) ValidateAuthentication(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, SIGNEDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ValidateAuthentication(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/ver1/accounts/currency_rates", wrapper.GetCurrencyRates)
	m.HandleFunc("GET "+options.BaseURL+"/ver1/accounts/currency_rates_with_leverage_data", wrapper.GetCurrencyRatesWithLeverageData)
	m.HandleFunc("GET "+options.BaseURL+"/ver1/accounts/market_list", wrapper.GetMarketList)
	m.HandleFunc("GET "+options.BaseURL+"/ver1/accounts/market_pairs", wrapper.GetMarketPairs)
	m.HandleFunc("GET "+options.BaseURL+"/ver1/bots", wrapper.ListBots)
	m.HandleFunc("POST "+options.BaseURL+"/ver1/bots/create_bot", wrapper.CreateDcaBot)
	m.HandleFunc("GET "+options.BaseURL+"/ver1/bots/pairs_black_list", wrapper.GetPairsBlacklist)
	m.HandleFunc("GET "+options.BaseURL+"/ver1/bots/stats", wrapper.GetBotsStats)
	m.HandleFunc("GET "+options.BaseURL+"/ver1/bots/stats_by_date", wrapper.GetBotsStatsByDate)
	m.HandleFunc("GET "+options.BaseURL+"/ver1/bots/strategy_list", wrapper.ListStrategies)
	m.HandleFunc("POST "+options.BaseURL+"/ver1/bots/update_pairs_black_list", wrapper.UpdatePairsBlacklist)
	m.HandleFunc("POST "+options.BaseURL+"/ver1/bots/{bot_id}/cancel_all_deals", wrapper.CancelAllDeals)
	m.HandleFunc("POST "+options.BaseURL+"/ver1/bots/{bot_id}/copy_and_create", wrapper.CopyAndCreateBot)
	m.HandleFunc("GET "+options.BaseURL+"/ver1/bots/{bot_id}/deals_stats", wrapper.GetDealsStats)
	m.HandleFunc("POST "+options.BaseURL+"/ver1/bots/{bot_id}/delete", wrapper.DeleteBot)
	m.HandleFunc("POST "+options.BaseURL+"/ver1/bots/{bot_id}/disable", wrapper.DisableBot)
	m.HandleFunc("POST "+options.BaseURL+"/ver1/bots/{bot_id}/enable", wrapper.EnableBot)
	m.HandleFunc("POST "+options.BaseURL+"/ver1/bots/{bot_id}/panic_sell_all_deals", wrapper.PanicSellAllDeals)
	m.HandleFunc("GET "+options.BaseURL+"/ver1/bots/{bot_id}/profit_by_day", wrapper.GetProfitByDay)
	m.HandleFunc("GET "+options.BaseURL+"/ver1/bots/{bot_id}/show", wrapper.GetBot)
	m.HandleFunc("PATCH "+options.BaseURL+"/ver1/bots/{bot_id}/update", wrapper.UpdateBot)
	m.HandleFunc("GET "+options.BaseURL+"/ver1/deals", wrapper.ListDeals)
	m.HandleFunc("POST "+options.BaseURL+"/ver1/deals/{deal_id}/cancel", wrapper.CancelDeal)
	m.HandleFunc("GET "+options.BaseURL+"/ver1/deals/{deal_id}/data_for_adding_funds", wrapper.GetDealDataForAddingFunds)
	m.HandleFunc("GET "+options.BaseURL+"/ver1/deals/{deal_id}/market_orders", wrapper.GetTradesOfDeal)
	m.HandleFunc("POST "+options.BaseURL+"/ver1/deals/{deal_id}/panic_sell", wrapper.PanicSellDeal)
	m.HandleFunc("POST "+options.BaseURL+"/ver1/deals/{deal_id}/panic_sell_step", wrapper.PanicSellDealStep)
	m.HandleFunc("GET "+options.BaseURL+"/ver1/deals/{deal_id}/show", wrapper.GetDeal)
	m.HandleFunc("PATCH "+options.BaseURL+"/ver1/deals/{deal_id}/update_deal", wrapper.UpdateDeal)
	m.HandleFunc("GET "+options.BaseURL+"/ver1/validate", wrapper.ValidateAuthentication)

	return m
}
